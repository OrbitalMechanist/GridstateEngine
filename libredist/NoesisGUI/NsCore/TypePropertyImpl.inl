////////////////////////////////////////////////////////////////////////////////////////////////////
// NoesisGUI - http://www.noesisengine.com
// Copyright (c) 2013 Noesis Technologies S.L. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////////////////////////////


#include <NsCore/TypeOf.h>
#include <NsCore/TypePropertyUtil.h>


namespace Noesis
{

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
TypePropertyOffset<T>::TypePropertyOffset(Symbol name, uint32_t offset):
    TypeProperty(name, TypeOf<TT>()), mOffset(offset)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void* TypePropertyOffset<T>::GetContent(const void* ptr) const
{
    return (uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
bool TypePropertyOffset<T>::IsReadOnly() const
{
    return IsConst<T>::Result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<BaseComponent> TypePropertyOffset<T>::GetComponent(const void* ptr) const
{
    return Noesis::GetComponent<TT>(this, ptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void TypePropertyOffset<T>::SetComponent(void* ptr, BaseComponent* value) const
{
    Noesis::SetComponent<TT>(this, ptr, value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
const void* TypePropertyOffset<T>::Get(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void TypePropertyOffset<T>::Get(const void* ptr, void* dest) const
{
    TT* storage = static_cast<TT*>(dest);
    *storage = *(TT*)((const uint8_t*)ptr + mOffset);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void TypePropertyOffset<T>::Set(void* ptr, const void* value) const
{
    *(TT*)((uint8_t*)ptr + mOffset) = *static_cast<const TT*>(value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
TypePropertyArray<T,N>::TypePropertyArray(Symbol name, uint32_t offset):
    TypeProperty(name, TypeOf<T[N]>()), mOffset(offset)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
void* TypePropertyArray<T,N>::GetContent(const void* ptr) const
{
    return (uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
bool TypePropertyArray<T,N>::IsReadOnly() const
{
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
const void* TypePropertyArray<T,N>::Get(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
const void* TypePropertyFunction<C,T>::ByRef::GetRef(GetterFn getter, const void* ptr)
{
    return &(static_cast<const C*>(ptr)->*getter)();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::ByRef::GetCopy(GetterFn, const void*, void*)
{
    // Should return value by reference
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
const void* TypePropertyFunction<C,T>::ByCopy::GetRef(GetterFn, const void*)
{
    // Can't get a reference to an unnamed value
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::ByCopy::GetCopy(GetterFn getter, const void* ptr, void* dest)
{
    // We need to split this in two lines or GCC 7 - 8 - 9 will ignore the assignment (bug?)
    T r = (static_cast<const C*>(ptr)->*getter)();
    *(static_cast<T*>(dest)) = r;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
TypePropertyFunction<C,T>::TypePropertyFunction(Symbol name, GetterFn getter, SetterFn setter):
    TypeProperty(name, TypeOf<T>()), mGetter(getter), mSetter(setter)
{
    NS_ASSERT(mGetter);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void* TypePropertyFunction<C,T>::GetContent(const void* ptr) const
{
    return const_cast<void*>(Helper::GetRef(mGetter, ptr));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
bool TypePropertyFunction<C,T>::IsReadOnly() const
{
    return mSetter == 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
Ptr<BaseComponent> TypePropertyFunction<C,T>::GetComponent(const void* ptr) const
{
    return Noesis::GetComponent<T>(this, ptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::SetComponent(void* ptr, BaseComponent* value) const
{
    Noesis::SetComponent<T>(this, ptr, value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
const void* TypePropertyFunction<C,T>::Get(const void* ptr) const
{
    return Helper::GetRef(mGetter, ptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::Get(const void* ptr, void* dest) const
{
    Helper::GetCopy(mGetter, ptr, dest);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::Set(void* ptr, const void* value) const
{
    NS_ASSERT(mSetter);
    (static_cast<C*>(ptr)->*mSetter)(*static_cast<const T*>(value));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
inline TypePropertyOffsetEvent::TypePropertyOffsetEvent(Symbol name, uint32_t offset):
    TypeProperty(name, nullptr), mOffset(offset)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline void* TypePropertyOffsetEvent::GetContent(const void* ptr) const
{
    return (uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool TypePropertyOffsetEvent::IsReadOnly() const
{
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline const void* TypePropertyOffsetEvent::Get(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
TypePropertyFunctionEvent<C>::TypePropertyFunctionEvent(Symbol name, GetterFn getter):
    TypeProperty(name, nullptr), mGetter(getter)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
void* TypePropertyFunctionEvent<C>::GetContent(const void* ptr) const
{
    return ((C*)(ptr)->*mGetter)();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
bool TypePropertyFunctionEvent<C>::IsReadOnly() const
{
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
const void* TypePropertyFunctionEvent<C>::Get(const void* ptr) const
{
    return ((C*)(ptr)->*mGetter)();
}

}
